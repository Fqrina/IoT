<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ESP32 Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>ESP32 Dashboard</h1>
  <p><button onclick="askPrediction()">Minta Prediksi</button></p>
  <p id="pred">No prediction yet</p>
  <p id="pdes"></p>
  <p id="next_volt"></p>
  <p id="confid"></p>
  <canvas id="vChart"></canvas>

  <script>
    const chart = new Chart(document.getElementById('vChart'), {
      type: 'line',
      data: { labels: [], datasets: [{ label: 'Voltage', data: [] }] }
    });

    async function loadData() {
      const res = await fetch('/api/data');
      const rows = await res.json();
      chart.data.labels = rows.map(r => new Date(r.ts*1000).toLocaleTimeString());
      chart.data.datasets[0].data = rows.map(r => r.voltage);
      chart.update();
    }

    async function loadPrediction() {
      const res = await fetch('/api/prediction/latest');
      const js = await res.json();
      const box = document.getElementById('pred');
      if(!js.ok) { box.textContent = js.error || 'No prediction'; return; }
      if(js.data){
        box.textContent = `Next voltage: ${js.data.next_voltage} (${js.data.confidence}) â€” ${js.data.description}`;
      } else {
        box.textContent = js.text;
      }
    }

    async function askPrediction(){
      await fetch('/get/response');  // trigger Gemini call
      loadPrediction();              // tampilkan hasil terbaru
    }

    // load awal
    loadData();
    loadPrediction();
    setInterval(loadData, 30000);    // refresh data 30s
    setInterval(loadPrediction, 30000);
  </script>
  <script>
    // Helper to extract JSON even if wrapped with ```json ... ``` fences
    function parseJsonish(txt){
      if (!txt || typeof txt !== 'string') return null;
      let t = txt.trim();
      // Strip code fences like ```json ... ```
      t = t.replace(/^```\s*json\s*/i, '').replace(/^```\s*/i, '');
      t = t.replace(/```\s*$/i, '');
      // If still has surrounding text, try to grab the first {...} block
      const start = t.indexOf('{');
      const end = t.lastIndexOf('}');
      if (start !== -1 && end !== -1 && end > start) {
        t = t.substring(start, end+1);
      }
      try { return JSON.parse(t); } catch { return null; }
    }

    // Override: show newest on the right and also fill JSON placeholders
    async function refreshChartAndPrediction() {
      try {
        const res = await fetch('/api/data');
        const rows = await res.json();
        const ordered = rows.slice().reverse();
        chart.data.labels = ordered.map(r => new Date(r.ts*1000).toLocaleTimeString());
        chart.data.datasets[0].data = ordered.map(r => r.voltage);
        chart.update();
      } catch (e) { /* noop */ }

      try {
        const res = await fetch('/api/prediction/latest');
        const js = await res.json();
        const box = document.getElementById('pred');
        const pdes = document.getElementById('pdes');
        const nvolt = document.getElementById('next_volt');
        const confid = document.getElementById('confid');
        if(!js.ok) { box.textContent = js.error || 'No prediction'; return; }
        // Keep whatever the server returns visible in #pred
        box.textContent = js.data ? JSON.stringify(js.data) : (js.text || '');
        // Fill placeholders from object or parsed text
        const d = js.data || parseJsonish(js.text);
        if (d) {
          if(pdes) pdes.textContent = d.description ?? '';
          if(nvolt) nvolt.textContent = d.next_voltage ?? '';
          if(confid) confid.textContent = d.confidence ?? '';
        }
      } catch (e) { /* noop */ }
    }

    // Override askPrediction to also refresh formatted output
    window.askPrediction = async function(){
      await fetch('/get/response');
      await refreshChartAndPrediction();
    }

    // Kick off our formatted refresh loop
    refreshChartAndPrediction();
    setInterval(refreshChartAndPrediction, 30000);
  </script>
</body>
</html>
